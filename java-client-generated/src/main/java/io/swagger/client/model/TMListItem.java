/*
 * TMI (Threat Modeling Improved) API
 * A RESTful API for collaborative threat modeling with full X6 graph library compatibility. This API provides schemas that align with AntV X6 cell object models for seamless integration with modern diagramming libraries. Supports OAuth 2.0 authentication with client callback integration for seamless single-page application authentication flows.  ## API Design v1.0.0  ### Authorization Model TMI uses hierarchical authorization: access control is defined at the ThreatModel level via the authorization field (readers, writers, owners). All child resources (Assets, Diagrams, Documents, Notes, Repositories, Threats) inherit permissions from their parent ThreatModel. This simplifies permission management and ensures consistent access control.  ### Bulk Operations Notes and Diagrams do not support bulk operations due to their unique creation workflows and lack of valid bulk use cases. All other resources (Threats, Assets, Documents, Repositories) support full bulk operations: POST (create), PUT (upsert), PATCH (partial update), DELETE (batch delete).  All resources support bulk metadata operations regardless of resource-level bulk support.  ### List Response Strategy - ThreatModels return summary information (TMListItem) because they contain many child objects that can be large. - Diagrams return summary information (DiagramListItem) because diagram data (cells, images) can be large. - Notes return summary information (NoteListItem) because the content field can be large. - Threats, Assets, Documents, Repositories return full schemas as they are relatively small and static.  ### PATCH Support All resources support PATCH for partial updates using JSON Patch (RFC 6902). This is particularly useful for: - Assets: Array field updates (affected_assets, trust_boundaries) ensuring no duplicates - Notes: Updating name/description without changing content field - All resources: Efficient updates without full object replacement 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.threeten.bp.OffsetDateTime;
/**
 * Enhanced item for threat model list endpoints with key metadata and counts
 */
@Schema(description = "Enhanced item for threat model list endpoints with key metadata and counts")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-11-03T03:28:24.639330576Z[GMT]")

public class TMListItem {
  @SerializedName("id")
  private UUID id = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("created_at")
  private OffsetDateTime createdAt = null;

  @SerializedName("modified_at")
  private OffsetDateTime modifiedAt = null;

  @SerializedName("owner")
  private String owner = null;

  @SerializedName("created_by")
  private String createdBy = null;

  @SerializedName("threat_model_framework")
  private String threatModelFramework = null;

  @SerializedName("document_count")
  private Integer documentCount = null;

  @SerializedName("repo_count")
  private Integer repoCount = null;

  @SerializedName("diagram_count")
  private Integer diagramCount = null;

  @SerializedName("threat_count")
  private Integer threatCount = null;

  @SerializedName("issue_uri")
  private String issueUri = null;

  @SerializedName("asset_count")
  private Integer assetCount = null;

  @SerializedName("note_count")
  private Integer noteCount = null;

  @SerializedName("status")
  private List<String> status = null;

  @SerializedName("status_updated")
  private OffsetDateTime statusUpdated = null;

   /**
   * Unique identifier of the threat model (UUID)
   * @return id
  **/
  @Schema(required = true, description = "Unique identifier of the threat model (UUID)")
  public UUID getId() {
    return id;
  }

  public TMListItem name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the threat model
   * @return name
  **/
  @Schema(required = true, description = "Name of the threat model")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public TMListItem description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Description of the threat model
   * @return description
  **/
  @Schema(description = "Description of the threat model")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public TMListItem createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * Creation timestamp (RFC3339)
   * @return createdAt
  **/
  @Schema(required = true, description = "Creation timestamp (RFC3339)")
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }

  public TMListItem modifiedAt(OffsetDateTime modifiedAt) {
    this.modifiedAt = modifiedAt;
    return this;
  }

   /**
   * Last modification timestamp (RFC3339)
   * @return modifiedAt
  **/
  @Schema(required = true, description = "Last modification timestamp (RFC3339)")
  public OffsetDateTime getModifiedAt() {
    return modifiedAt;
  }

  public void setModifiedAt(OffsetDateTime modifiedAt) {
    this.modifiedAt = modifiedAt;
  }

  public TMListItem owner(String owner) {
    this.owner = owner;
    return this;
  }

   /**
   * Email address of the current owner
   * @return owner
  **/
  @Schema(required = true, description = "Email address of the current owner")
  public String getOwner() {
    return owner;
  }

  public void setOwner(String owner) {
    this.owner = owner;
  }

  public TMListItem createdBy(String createdBy) {
    this.createdBy = createdBy;
    return this;
  }

   /**
   * Email address, name or identifier of the creator
   * @return createdBy
  **/
  @Schema(required = true, description = "Email address, name or identifier of the creator")
  public String getCreatedBy() {
    return createdBy;
  }

  public void setCreatedBy(String createdBy) {
    this.createdBy = createdBy;
  }

  public TMListItem threatModelFramework(String threatModelFramework) {
    this.threatModelFramework = threatModelFramework;
    return this;
  }

   /**
   * The framework used for this threat model
   * @return threatModelFramework
  **/
  @Schema(required = true, description = "The framework used for this threat model")
  public String getThreatModelFramework() {
    return threatModelFramework;
  }

  public void setThreatModelFramework(String threatModelFramework) {
    this.threatModelFramework = threatModelFramework;
  }

  public TMListItem documentCount(Integer documentCount) {
    this.documentCount = documentCount;
    return this;
  }

   /**
   * Number of documents associated with this threat model
   * minimum: 0
   * @return documentCount
  **/
  @Schema(required = true, description = "Number of documents associated with this threat model")
  public Integer getDocumentCount() {
    return documentCount;
  }

  public void setDocumentCount(Integer documentCount) {
    this.documentCount = documentCount;
  }

  public TMListItem repoCount(Integer repoCount) {
    this.repoCount = repoCount;
    return this;
  }

   /**
   * Number of source code repository entries associated with this threat model
   * minimum: 0
   * @return repoCount
  **/
  @Schema(required = true, description = "Number of source code repository entries associated with this threat model")
  public Integer getRepoCount() {
    return repoCount;
  }

  public void setRepoCount(Integer repoCount) {
    this.repoCount = repoCount;
  }

  public TMListItem diagramCount(Integer diagramCount) {
    this.diagramCount = diagramCount;
    return this;
  }

   /**
   * Number of diagrams associated with this threat model
   * minimum: 0
   * @return diagramCount
  **/
  @Schema(required = true, description = "Number of diagrams associated with this threat model")
  public Integer getDiagramCount() {
    return diagramCount;
  }

  public void setDiagramCount(Integer diagramCount) {
    this.diagramCount = diagramCount;
  }

  public TMListItem threatCount(Integer threatCount) {
    this.threatCount = threatCount;
    return this;
  }

   /**
   * Number of threats defined in this threat model
   * minimum: 0
   * @return threatCount
  **/
  @Schema(required = true, description = "Number of threats defined in this threat model")
  public Integer getThreatCount() {
    return threatCount;
  }

  public void setThreatCount(Integer threatCount) {
    this.threatCount = threatCount;
  }

  public TMListItem issueUri(String issueUri) {
    this.issueUri = issueUri;
    return this;
  }

   /**
   * URL to an issue in an issue tracking system
   * @return issueUri
  **/
  @Schema(description = "URL to an issue in an issue tracking system")
  public String getIssueUri() {
    return issueUri;
  }

  public void setIssueUri(String issueUri) {
    this.issueUri = issueUri;
  }

  public TMListItem assetCount(Integer assetCount) {
    this.assetCount = assetCount;
    return this;
  }

   /**
   * Number of assets associated with this threat model
   * minimum: 0
   * @return assetCount
  **/
  @Schema(required = true, description = "Number of assets associated with this threat model")
  public Integer getAssetCount() {
    return assetCount;
  }

  public void setAssetCount(Integer assetCount) {
    this.assetCount = assetCount;
  }

  public TMListItem noteCount(Integer noteCount) {
    this.noteCount = noteCount;
    return this;
  }

   /**
   * Number of notes associated with this threat model
   * minimum: 0
   * @return noteCount
  **/
  @Schema(required = true, description = "Number of notes associated with this threat model")
  public Integer getNoteCount() {
    return noteCount;
  }

  public void setNoteCount(Integer noteCount) {
    this.noteCount = noteCount;
  }

  public TMListItem status(List<String> status) {
    this.status = status;
    return this;
  }

  public TMListItem addStatusItem(String statusItem) {
    if (this.status == null) {
      this.status = new ArrayList<String>();
    }
    this.status.add(statusItem);
    return this;
  }

   /**
   * Status of the threat model in the organization&#x27;s threat modeling or SDLC process. Examples: \&quot;Not started\&quot;, \&quot;In progress\&quot;, \&quot;Review\&quot;, \&quot;Approved\&quot;, \&quot;Closed\&quot;
   * @return status
  **/
  @Schema(description = "Status of the threat model in the organization's threat modeling or SDLC process. Examples: \"Not started\", \"In progress\", \"Review\", \"Approved\", \"Closed\"")
  public List<String> getStatus() {
    return status;
  }

  public void setStatus(List<String> status) {
    this.status = status;
  }

   /**
   * Timestamp when the status field was last modified (RFC3339). Automatically updated by the server when status changes.
   * @return statusUpdated
  **/
  @Schema(description = "Timestamp when the status field was last modified (RFC3339). Automatically updated by the server when status changes.")
  public OffsetDateTime getStatusUpdated() {
    return statusUpdated;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TMListItem tmListItem = (TMListItem) o;
    return Objects.equals(this.id, tmListItem.id) &&
        Objects.equals(this.name, tmListItem.name) &&
        Objects.equals(this.description, tmListItem.description) &&
        Objects.equals(this.createdAt, tmListItem.createdAt) &&
        Objects.equals(this.modifiedAt, tmListItem.modifiedAt) &&
        Objects.equals(this.owner, tmListItem.owner) &&
        Objects.equals(this.createdBy, tmListItem.createdBy) &&
        Objects.equals(this.threatModelFramework, tmListItem.threatModelFramework) &&
        Objects.equals(this.documentCount, tmListItem.documentCount) &&
        Objects.equals(this.repoCount, tmListItem.repoCount) &&
        Objects.equals(this.diagramCount, tmListItem.diagramCount) &&
        Objects.equals(this.threatCount, tmListItem.threatCount) &&
        Objects.equals(this.issueUri, tmListItem.issueUri) &&
        Objects.equals(this.assetCount, tmListItem.assetCount) &&
        Objects.equals(this.noteCount, tmListItem.noteCount) &&
        Objects.equals(this.status, tmListItem.status) &&
        Objects.equals(this.statusUpdated, tmListItem.statusUpdated);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, description, createdAt, modifiedAt, owner, createdBy, threatModelFramework, documentCount, repoCount, diagramCount, threatCount, issueUri, assetCount, noteCount, status, statusUpdated);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TMListItem {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    modifiedAt: ").append(toIndentedString(modifiedAt)).append("\n");
    sb.append("    owner: ").append(toIndentedString(owner)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    threatModelFramework: ").append(toIndentedString(threatModelFramework)).append("\n");
    sb.append("    documentCount: ").append(toIndentedString(documentCount)).append("\n");
    sb.append("    repoCount: ").append(toIndentedString(repoCount)).append("\n");
    sb.append("    diagramCount: ").append(toIndentedString(diagramCount)).append("\n");
    sb.append("    threatCount: ").append(toIndentedString(threatCount)).append("\n");
    sb.append("    issueUri: ").append(toIndentedString(issueUri)).append("\n");
    sb.append("    assetCount: ").append(toIndentedString(assetCount)).append("\n");
    sb.append("    noteCount: ").append(toIndentedString(noteCount)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    statusUpdated: ").append(toIndentedString(statusUpdated)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
