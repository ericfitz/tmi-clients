# coding: utf-8

"""
    TMI (Threat Modeling Improved) API

    A RESTful API for collaborative threat modeling with full X6 graph library compatibility. This API provides schemas that align with AntV X6 cell object models for seamless integration with modern diagramming libraries. Supports OAuth 2.0 authentication with client callback integration for seamless single-page application authentication flows.  ## API Design v1.0.0  ### Authorization Model TMI uses hierarchical authorization: access control is defined at the ThreatModel level via the authorization field (readers, writers, owners). All child resources (Assets, Diagrams, Documents, Notes, Repositories, Threats) inherit permissions from their parent ThreatModel. This simplifies permission management and ensures consistent access control.  ### Bulk Operations Notes and Diagrams do not support bulk operations due to their unique creation workflows and lack of valid bulk use cases. All other resources (Threats, Assets, Documents, Repositories) support full bulk operations: POST (create), PUT (upsert), PATCH (partial update), DELETE (batch delete).  All resources support bulk metadata operations regardless of resource-level bulk support.  ### List Response Strategy - ThreatModels return summary information (TMListItem) because they contain many child objects that can be large. - Diagrams return summary information (DiagramListItem) because diagram data (cells, images) can be large. - Notes return summary information (NoteListItem) because the content field can be large. - Threats, Assets, Documents, Repositories return full schemas as they are relatively small and static.  ### PATCH Support All resources support PATCH for partial updates using JSON Patch (RFC 6902). This is particularly useful for: - Assets: Array field updates (affected_assets, trust_boundaries) ensuring no duplicates - Notes: Updating name/description without changing content field - All resources: Efficient updates without full object replacement   # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: api@tmi.dev
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tmi_client.api_client import ApiClient


class AdministrationApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_group_member(self, body, internal_uuid, **kwargs):  # noqa: E501
        """Add member to group  # noqa: E501

        Adds a user to a group. The user must exist in the system. Cannot add members to the special 'everyone' pseudo-group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_group_member(body, internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddGroupMemberRequest body: (required)
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: GroupMember
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_group_member_with_http_info(body, internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_group_member_with_http_info(body, internal_uuid, **kwargs)  # noqa: E501
            return data

    def add_group_member_with_http_info(self, body, internal_uuid, **kwargs):  # noqa: E501
        """Add member to group  # noqa: E501

        Adds a user to a group. The user must exist in the system. Cannot add members to the special 'everyone' pseudo-group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_group_member_with_http_info(body, internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddGroupMemberRequest body: (required)
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: GroupMember
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_group_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_group_member`")  # noqa: E501
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `add_group_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups/{internal_uuid}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroupMember',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_admin_group(self, body, **kwargs):  # noqa: E501
        """Create provider-independent group  # noqa: E501

        Creates a new provider-independent group (provider=\"*\"). These groups can be used across all providers for authorization and administration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_admin_group(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateAdminGroupRequest body: (required)
        :return: AdminGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_admin_group_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_admin_group_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_admin_group_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create provider-independent group  # noqa: E501

        Creates a new provider-independent group (provider=\"*\"). These groups can be used across all providers for authorization and administration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_admin_group_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateAdminGroupRequest body: (required)
        :return: AdminGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_admin_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_admin_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_administrator(self, body, **kwargs):  # noqa: E501
        """Create administrator grant  # noqa: E501

        Grants administrator privileges to a user or group for a specific provider. Exactly one of email, provider_user_id, or group_name must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_administrator(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateAdministratorRequest body: (required)
        :return: Administrator
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_administrator_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_administrator_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_administrator_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create administrator grant  # noqa: E501

        Grants administrator privileges to a user or group for a specific provider. Exactly one of email, provider_user_id, or group_name must be specified.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_administrator_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateAdministratorRequest body: (required)
        :return: Administrator
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_administrator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_administrator`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/administrators', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Administrator',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_addon_invocation_quota(self, user_id, **kwargs):  # noqa: E501
        """Delete addon invocation quota  # noqa: E501

        Deletes the custom addon invocation quota for a user, reverting to system defaults  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_addon_invocation_quota(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_addon_invocation_quota_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_addon_invocation_quota_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_addon_invocation_quota_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete addon invocation quota  # noqa: E501

        Deletes the custom addon invocation quota for a user, reverting to system defaults  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_addon_invocation_quota_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_addon_invocation_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_addon_invocation_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/addons/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_admin_group(self, internal_uuid, **kwargs):  # noqa: E501
        """Delete group  # noqa: E501

        Deletes a TMI-managed group and handles threat model cleanup. Protected groups like 'everyone' cannot be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_group(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_admin_group_with_http_info(internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_admin_group_with_http_info(internal_uuid, **kwargs)  # noqa: E501
            return data

    def delete_admin_group_with_http_info(self, internal_uuid, **kwargs):  # noqa: E501
        """Delete group  # noqa: E501

        Deletes a TMI-managed group and handles threat model cleanup. Protected groups like 'everyone' cannot be deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_group_with_http_info(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_admin_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `delete_admin_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups/{internal_uuid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_admin_user(self, internal_uuid, **kwargs):  # noqa: E501
        """Delete user  # noqa: E501

        Deletes a user and all associated data. Transfers sole-owned threat models or deletes them if no other owners exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_user(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_admin_user_with_http_info(internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_admin_user_with_http_info(internal_uuid, **kwargs)  # noqa: E501
            return data

    def delete_admin_user_with_http_info(self, internal_uuid, **kwargs):  # noqa: E501
        """Delete user  # noqa: E501

        Deletes a user and all associated data. Transfers sole-owned threat models or deletes them if no other owners exist.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_admin_user_with_http_info(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_admin_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `delete_admin_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/users/{internal_uuid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_administrator(self, id, **kwargs):  # noqa: E501
        """Delete administrator grant  # noqa: E501

        Revokes administrator privileges. Users cannot revoke their own privileges or privileges for groups they belong to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_administrator(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Administrator grant ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_administrator_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_administrator_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_administrator_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete administrator grant  # noqa: E501

        Revokes administrator privileges. Users cannot revoke their own privileges or privileges for groups they belong to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_administrator_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Administrator grant ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_administrator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_administrator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/administrators/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_api_quota(self, user_id, **kwargs):  # noqa: E501
        """Delete user API quota  # noqa: E501

        Deletes the custom API quota for a user, reverting to system defaults  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_api_quota(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_user_api_quota_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_api_quota_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_api_quota_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete user API quota  # noqa: E501

        Deletes the custom API quota for a user, reverting to system defaults  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_api_quota_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_api_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_api_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/users/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_webhook_quota(self, user_id, **kwargs):  # noqa: E501
        """Delete webhook quota  # noqa: E501

        Deletes the custom webhook quota for a user, reverting to system defaults  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_webhook_quota(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_webhook_quota_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_webhook_quota_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_webhook_quota_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete webhook quota  # noqa: E501

        Deletes the custom webhook quota for a user, reverting to system defaults  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_webhook_quota_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_webhook_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_webhook_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/webhooks/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_addon_invocation_quota(self, user_id, **kwargs):  # noqa: E501
        """Get addon invocation quota  # noqa: E501

        Retrieves the addon invocation quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_addon_invocation_quota(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: AddonInvocationQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_addon_invocation_quota_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_addon_invocation_quota_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_addon_invocation_quota_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get addon invocation quota  # noqa: E501

        Retrieves the addon invocation quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_addon_invocation_quota_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: AddonInvocationQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_addon_invocation_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_addon_invocation_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/addons/{user_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddonInvocationQuota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_group(self, internal_uuid, **kwargs):  # noqa: E501
        """Get group details  # noqa: E501

        Returns detailed information about a specific group, including enriched data (usage in authorizations and admin grants).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_group(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_admin_group_with_http_info(internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_group_with_http_info(internal_uuid, **kwargs)  # noqa: E501
            return data

    def get_admin_group_with_http_info(self, internal_uuid, **kwargs):  # noqa: E501
        """Get group details  # noqa: E501

        Returns detailed information about a specific group, including enriched data (usage in authorizations and admin grants).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_group_with_http_info(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `get_admin_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups/{internal_uuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_admin_user(self, internal_uuid, **kwargs):  # noqa: E501
        """Get user details  # noqa: E501

        Returns detailed information about a specific user, including enriched data (admin status, groups, threat model counts).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_user(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_admin_user_with_http_info(internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_admin_user_with_http_info(internal_uuid, **kwargs)  # noqa: E501
            return data

    def get_admin_user_with_http_info(self, internal_uuid, **kwargs):  # noqa: E501
        """Get user details  # noqa: E501

        Returns detailed information about a specific user, including enriched data (admin status, groups, threat model counts).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_admin_user_with_http_info(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_admin_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `get_admin_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/users/{internal_uuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_api_quota(self, user_id, **kwargs):  # noqa: E501
        """Get user API quota  # noqa: E501

        Retrieves the API rate limit quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_api_quota(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: UserAPIQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_api_quota_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_api_quota_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_user_api_quota_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get user API quota  # noqa: E501

        Retrieves the API rate limit quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_api_quota_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: UserAPIQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_api_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_api_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/users/{user_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserAPIQuota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook_quota(self, user_id, **kwargs):  # noqa: E501
        """Get webhook quota  # noqa: E501

        Retrieves the webhook quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_quota(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: WebhookQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_webhook_quota_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_webhook_quota_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_webhook_quota_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get webhook quota  # noqa: E501

        Retrieves the webhook quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_quota_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User ID (required)
        :return: WebhookQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_webhook_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/webhooks/{user_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebhookQuota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_addon_invocation_quotas(self, **kwargs):  # noqa: E501
        """List all addon invocation quotas  # noqa: E501

        Retrieves all custom addon invocation quotas (users with non-default quotas)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_addon_invocation_quotas(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: list[AddonInvocationQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_addon_invocation_quotas_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_addon_invocation_quotas_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_addon_invocation_quotas_with_http_info(self, **kwargs):  # noqa: E501
        """List all addon invocation quotas  # noqa: E501

        Retrieves all custom addon invocation quotas (users with non-default quotas)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_addon_invocation_quotas_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: list[AddonInvocationQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_addon_invocation_quotas" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/addons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AddonInvocationQuota]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_admin_groups(self, **kwargs):  # noqa: E501
        """List groups  # noqa: E501

        Returns a paginated list of groups with optional filtering by provider, name, and usage. Includes enriched data (usage in authorizations and admin grants).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_admin_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str provider: Filter by OAuth/SAML provider
        :param str group_name: Filter by group name (case-insensitive substring match)
        :param bool used_in_authorizations: Filter groups used (true) or not used (false) in authorizations
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :param str sort_by: Field to sort by
        :param str sort_order: Sort direction
        :return: AdminGroupListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_admin_groups_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_admin_groups_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_admin_groups_with_http_info(self, **kwargs):  # noqa: E501
        """List groups  # noqa: E501

        Returns a paginated list of groups with optional filtering by provider, name, and usage. Includes enriched data (usage in authorizations and admin grants).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_admin_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str provider: Filter by OAuth/SAML provider
        :param str group_name: Filter by group name (case-insensitive substring match)
        :param bool used_in_authorizations: Filter groups used (true) or not used (false) in authorizations
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :param str sort_by: Field to sort by
        :param str sort_order: Sort direction
        :return: AdminGroupListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['provider', 'group_name', 'used_in_authorizations', 'limit', 'offset', 'sort_by', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_admin_groups" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'provider' in params:
            query_params.append(('provider', params['provider']))  # noqa: E501
        if 'group_name' in params:
            query_params.append(('group_name', params['group_name']))  # noqa: E501
        if 'used_in_authorizations' in params:
            query_params.append(('used_in_authorizations', params['used_in_authorizations']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sort_order', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminGroupListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_admin_users(self, **kwargs):  # noqa: E501
        """List users  # noqa: E501

        Returns a paginated list of users with optional filtering by provider, email, and date ranges. Includes enriched data (admin status, groups, threat model counts).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_admin_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str provider: Filter by OAuth/SAML provider
        :param str email: Filter by email (case-insensitive substring match)
        :param datetime created_after: Filter users created after this timestamp (RFC3339)
        :param datetime created_before: Filter users created before this timestamp (RFC3339)
        :param datetime last_login_after: Filter users who logged in after this timestamp (RFC3339)
        :param datetime last_login_before: Filter users who logged in before this timestamp (RFC3339)
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :param str sort_by: Field to sort by
        :param str sort_order: Sort direction
        :return: AdminUserListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_admin_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_admin_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_admin_users_with_http_info(self, **kwargs):  # noqa: E501
        """List users  # noqa: E501

        Returns a paginated list of users with optional filtering by provider, email, and date ranges. Includes enriched data (admin status, groups, threat model counts).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_admin_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str provider: Filter by OAuth/SAML provider
        :param str email: Filter by email (case-insensitive substring match)
        :param datetime created_after: Filter users created after this timestamp (RFC3339)
        :param datetime created_before: Filter users created before this timestamp (RFC3339)
        :param datetime last_login_after: Filter users who logged in after this timestamp (RFC3339)
        :param datetime last_login_before: Filter users who logged in before this timestamp (RFC3339)
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :param str sort_by: Field to sort by
        :param str sort_order: Sort direction
        :return: AdminUserListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['provider', 'email', 'created_after', 'created_before', 'last_login_after', 'last_login_before', 'limit', 'offset', 'sort_by', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_admin_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'provider' in params:
            query_params.append(('provider', params['provider']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'last_login_after' in params:
            query_params.append(('last_login_after', params['last_login_after']))  # noqa: E501
        if 'last_login_before' in params:
            query_params.append(('last_login_before', params['last_login_before']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sort_order', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminUserListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_administrators(self, **kwargs):  # noqa: E501
        """List administrators  # noqa: E501

        Returns a list of administrator grants with optional filtering by provider, user, or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_administrators(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str provider: Filter by OAuth/SAML provider
        :param str user_id: Filter by user ID
        :param str group_id: Filter by group ID
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: ListAdministratorsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_administrators_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_administrators_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_administrators_with_http_info(self, **kwargs):  # noqa: E501
        """List administrators  # noqa: E501

        Returns a list of administrator grants with optional filtering by provider, user, or group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_administrators_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str provider: Filter by OAuth/SAML provider
        :param str user_id: Filter by user ID
        :param str group_id: Filter by group ID
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: ListAdministratorsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['provider', 'user_id', 'group_id', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_administrators" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'provider' in params:
            query_params.append(('provider', params['provider']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('user_id', params['user_id']))  # noqa: E501
        if 'group_id' in params:
            query_params.append(('group_id', params['group_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/administrators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListAdministratorsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_group_members(self, internal_uuid, **kwargs):  # noqa: E501
        """List group members  # noqa: E501

        Returns a paginated list of users who are members of the specified group. Includes user details (email, name, provider information).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_group_members(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: GroupMemberListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_group_members_with_http_info(internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.list_group_members_with_http_info(internal_uuid, **kwargs)  # noqa: E501
            return data

    def list_group_members_with_http_info(self, internal_uuid, **kwargs):  # noqa: E501
        """List group members  # noqa: E501

        Returns a paginated list of users who are members of the specified group. Includes user details (email, name, provider information).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_group_members_with_http_info(internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: GroupMemberListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['internal_uuid', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_group_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `list_group_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups/{internal_uuid}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GroupMemberListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_user_api_quotas(self, **kwargs):  # noqa: E501
        """List all user API quotas  # noqa: E501

        Retrieves all custom API rate limit quotas (users with non-default quotas)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_api_quotas(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: list[UserAPIQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_user_api_quotas_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_user_api_quotas_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_user_api_quotas_with_http_info(self, **kwargs):  # noqa: E501
        """List all user API quotas  # noqa: E501

        Retrieves all custom API rate limit quotas (users with non-default quotas)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_user_api_quotas_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: list[UserAPIQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_user_api_quotas" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserAPIQuota]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_webhook_quotas(self, **kwargs):  # noqa: E501
        """List all webhook quotas  # noqa: E501

        Retrieves all custom webhook quotas (users with non-default quotas)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_webhook_quotas(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: list[WebhookQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_webhook_quotas_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_webhook_quotas_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_webhook_quotas_with_http_info(self, **kwargs):  # noqa: E501
        """List all webhook quotas  # noqa: E501

        Retrieves all custom webhook quotas (users with non-default quotas)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_webhook_quotas_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: Maximum number of results to return
        :param int offset: Number of results to skip
        :return: list[WebhookQuota]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_webhook_quotas" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/webhooks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebhookQuota]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_group_member(self, internal_uuid, user_uuid, **kwargs):  # noqa: E501
        """Remove member from group  # noqa: E501

        Removes a user from a group. Cannot remove members from the special 'everyone' pseudo-group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_group_member(internal_uuid, user_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :param str user_uuid: Internal system UUID of the user to remove (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_group_member_with_http_info(internal_uuid, user_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_group_member_with_http_info(internal_uuid, user_uuid, **kwargs)  # noqa: E501
            return data

    def remove_group_member_with_http_info(self, internal_uuid, user_uuid, **kwargs):  # noqa: E501
        """Remove member from group  # noqa: E501

        Removes a user from a group. Cannot remove members from the special 'everyone' pseudo-group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_group_member_with_http_info(internal_uuid, user_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str internal_uuid: Internal system UUID of the user (required)
        :param str user_uuid: Internal system UUID of the user to remove (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['internal_uuid', 'user_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_group_member" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `remove_group_member`")  # noqa: E501
        # verify the required parameter 'user_uuid' is set
        if ('user_uuid' not in params or
                params['user_uuid'] is None):
            raise ValueError("Missing the required parameter `user_uuid` when calling `remove_group_member`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501
        if 'user_uuid' in params:
            path_params['user_uuid'] = params['user_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups/{internal_uuid}/members/{user_uuid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_addon_invocation_quota(self, body, user_id, **kwargs):  # noqa: E501
        """Update addon invocation quota  # noqa: E501

        Creates or updates the addon invocation quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_addon_invocation_quota(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddonQuotaUpdate body: (required)
        :param str user_id: User ID (required)
        :return: AddonInvocationQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_addon_invocation_quota_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_addon_invocation_quota_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def update_addon_invocation_quota_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Update addon invocation quota  # noqa: E501

        Creates or updates the addon invocation quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_addon_invocation_quota_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AddonQuotaUpdate body: (required)
        :param str user_id: User ID (required)
        :return: AddonInvocationQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_addon_invocation_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_addon_invocation_quota`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_addon_invocation_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/addons/{user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddonInvocationQuota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_admin_group(self, body, internal_uuid, **kwargs):  # noqa: E501
        """Update group metadata  # noqa: E501

        Updates group metadata fields (name, description). Only provided fields are updated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_group(body, internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateAdminGroupRequest body: (required)
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_admin_group_with_http_info(body, internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_admin_group_with_http_info(body, internal_uuid, **kwargs)  # noqa: E501
            return data

    def update_admin_group_with_http_info(self, body, internal_uuid, **kwargs):  # noqa: E501
        """Update group metadata  # noqa: E501

        Updates group metadata fields (name, description). Only provided fields are updated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_group_with_http_info(body, internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateAdminGroupRequest body: (required)
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_admin_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_admin_group`")  # noqa: E501
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `update_admin_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/groups/{internal_uuid}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_admin_user(self, body, internal_uuid, **kwargs):  # noqa: E501
        """Update user metadata  # noqa: E501

        Updates user metadata fields (email, name, email_verified). Only provided fields are updated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_user(body, internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateAdminUserRequest body: (required)
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_admin_user_with_http_info(body, internal_uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_admin_user_with_http_info(body, internal_uuid, **kwargs)  # noqa: E501
            return data

    def update_admin_user_with_http_info(self, body, internal_uuid, **kwargs):  # noqa: E501
        """Update user metadata  # noqa: E501

        Updates user metadata fields (email, name, email_verified). Only provided fields are updated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_admin_user_with_http_info(body, internal_uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateAdminUserRequest body: (required)
        :param str internal_uuid: Internal system UUID of the user (required)
        :return: AdminUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'internal_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_admin_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_admin_user`")  # noqa: E501
        # verify the required parameter 'internal_uuid' is set
        if ('internal_uuid' not in params or
                params['internal_uuid'] is None):
            raise ValueError("Missing the required parameter `internal_uuid` when calling `update_admin_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'internal_uuid' in params:
            path_params['internal_uuid'] = params['internal_uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/users/{internal_uuid}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminUser',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_api_quota(self, body, user_id, **kwargs):  # noqa: E501
        """Update user API quota  # noqa: E501

        Creates or updates the API rate limit quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_api_quota(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserQuotaUpdate body: (required)
        :param str user_id: User ID (required)
        :return: UserAPIQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_api_quota_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_api_quota_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def update_user_api_quota_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Update user API quota  # noqa: E501

        Creates or updates the API rate limit quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_api_quota_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserQuotaUpdate body: (required)
        :param str user_id: User ID (required)
        :return: UserAPIQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_api_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_user_api_quota`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_user_api_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/users/{user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserAPIQuota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_webhook_quota(self, body, user_id, **kwargs):  # noqa: E501
        """Update webhook quota  # noqa: E501

        Creates or updates the webhook quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_webhook_quota(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookQuotaUpdate body: (required)
        :param str user_id: User ID (required)
        :return: WebhookQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_webhook_quota_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_webhook_quota_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def update_webhook_quota_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Update webhook quota  # noqa: E501

        Creates or updates the webhook quota for a specific user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_webhook_quota_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookQuotaUpdate body: (required)
        :param str user_id: User ID (required)
        :return: WebhookQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_webhook_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_webhook_quota`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_webhook_quota`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/admin/quotas/webhooks/{user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebhookQuota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
